<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux下*.tar.gz文件解压缩命令]]></title>
    <url>%2F2018%2F08%2F01%2FLinux%E4%B8%8B-tar-gz%E6%96%87%E4%BB%B6%E8%A7%A3%E5%8E%8B%E7%BC%A9%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[写这篇博客的背后有个小故事的，前两天我们的开发环境一直处于挂起状态，找了好久都没能找到问题，后来是技术主管出马，终于找到了问题的根源。然后我一看，确实是开发环境有个文件夹没有了！（谁误删的站出来！！！）没办啦，我只好让运维人员帮忙打生产包，把这个文件下的所有东西从正式环境copy下路咯，然后我手动解压了*.tar.gz的压缩包，然后放到了开发环境的对应路径下，看我这么操作的技术主管在一旁笑了，笑了。。。我老脸一红，说为了快点恢复开发环境只好这样了，而且作为一个前端没有接触过这些东西嘛。所以，有了这么一篇关于Linux命令的笔记 —–漂亮的分隔线，开始正文—– 压缩命令命令格式：tar -zcvf 压缩文件名.tar.gz 被压缩文件名 可先切换到当前目录下，压缩文件名和被压缩文件名都可以加入路径。 解压缩命令命令格式：tar -zxvf 压缩文件名.tar.gz 解压缩后的文件只能放在当前的目录 具体的tar.gz的解压缩就是这样子，但是对于这些字符是什么意思我还是不晓得的，知其然更要知其所以然，才能记得住。 压缩说明命令：tar -zcvf 压缩文件名.tar.gz 选项： -z:解压缩类型为 .tar.gz -c:打包（建立压缩档案） -v:显示过程 -f:指定打包后的文件名 其实.tar.gz格式是先打包成.tar再压缩成.tar.gz 解压说明命令：tar -zxvf 压缩文件名.tar.gz 选项： -z:解压缩类型为.tar.gz -x:解压 -v:显示过程 -f:指定打包后的文件名 目前能用到的的就这个了，其他的先不说。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令总结]]></title>
    <url>%2F2018%2F06%2F13%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[对Git的命令总是不太清楚，在网上看了一些资料，然后总结也做个整理吧，写一遍，加深一下印象，不要总是看着去写，文章最后还有自己总结的Git命令思维导图一张。 废话不多说，开始正文 Git的一些基础命令一般配置git init //初始化 git --version //查看git的版本信息 git config --global user.name //获取当前登录的用户 git config --global user.email //获取当前登录用户的邮箱 git config --list //列出所有git当时能找到的配置 登录Git/*如果刚没有获取到用户配置，则只能拉取2代码，不能修改。要是使用git,你要告诉git是谁在使用*/ git config --global user.name &apos;userName&apos; //设置git账户，userName为你的git账号 git config --global user.email &apos;email&apos; 创建一个文件夹mkdir nodejs //创建文件夹nodejs cd nodejs //切换到nodejs目录下 创建忽略文件touch .gitignore //不需要服务器端提交的内容写到忽略文件里 查看目录ls -al 查看文件内容cat index.html 增加到暂缓区中git add index.html git add -A //全部添加到缓存区 增加到版本库中git commit -m &apos;备注信息&apos; 查看版本git log --oneline 比较差异git diff //比较的是暂存区和工作区的差异 git diff --cached //比较的是暂存区和历史区的差异 git diff master //比较的是历史区和工作区的差异（修改） git checkout idnex.html //用暂存区中的内容或者版本库中的内容覆盖掉工作区 git reset HEAD index.html //取消增加到暂存区的内容（添加时） git status //显示目录的状态，有没有添加或者修改文件 删除本地文件rm fileName 删除暂存区git rm index.html --cached //保证当前工作区中index.html 使用--cached表示只删除缓存区中的内容 回滚版本git reset --hard HEAD/commit_id //回滚最近的一个版本 操作记录查询/*可以查看所有分支的操作记录（包括commit和reset的操作），包括已经被删除的commit记录，gitlog则不能察看已经删除了的commit记录*/ git reflog 分支管理创建分支git branch dev 切换分支git checkout dev 创建分支并切换分支git checkout -b dev 删除分支git branch -d dev 在分支上提交新的版本git commit -a -m &apos;dev1&apos; 合并分支git merge dev 分支的合并后显示loggit log --oneline --graph --decorate 远程仓库添加远程仓库git remote add origin &lt;repo&gt; //添加远程仓库 git push -u origin master //添加本地master分支到远程仓库origin的master分支 git push -u origin master --force //强制推送本地的master分支到远程仓库origin的master支付，会覆盖远程 git pull //取回远程主机某个分支的更新，再与本地的指定分支合并 git clone &lt;reponame&gt; //克隆远程仓库到本地 git remote remove origin //删除本地与远程的关联 git remote -v 查询绑定的远程仓库 现在常用的就是这些了，get!最后就是一张图啦]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[注释那些事儿]]></title>
    <url>%2F2018%2F04%2F27%2F%E6%B3%A8%E9%87%8A%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%2F</url>
    <content type="text"><![CDATA[好的注释可以提高代码的可读性和可维护性，从而提高代码质量。 那么什么是好的注释？如何写出好的注释？本文将从注释的目的和原则出发对 JS 注释进行探讨。 1、注释的目的和原则注释的目的： 提高代码的可读性，从而提高代码的可维护性 注释的原则： 如无必要，勿增注释 ( As short as possible ) 如有必要，尽量详尽 ( As long as necessary ) 我们写注释，是为了给代码的读者（包括我们自己，也可能包括机器，如 jsdoc）看，帮助读者阅读理解代码并进行维护。 「如无必要，勿增注释」是指注释要避免过多过滥，不要为了注释而注释。多余的注释等价于冗余的代码，除了对增加可读性无益，一旦代码需要修改，修改注释也会是一大负担。我们应当追求「代码自注释」，即代码本身就拥有较高的可读性（通过清晰的命名、合理的结构等）。举个例子： // bad // 如果已经准备好数据，就渲染表格 if (data.success &amp;&amp; data.result.length &gt; 0) { renderTable(data); } // good const isTableDataReady = data.success &amp;&amp; data.result.length &gt; 0; if (isTableDataReady) { renderTable(data); } 「如有必要，尽量详尽」是指需要注释的地方应该尽量详尽地去写，以让阅读者可以充分了解代码的逻辑和意图为标准。 2、什么是好注释，什么是坏注释根据注释的原则，我们应该以「能否帮助阅读者更好地阅读理解代码」为标准，判断一个注释「是否有必要」。 好的注释包括： 帮助读者更好地了解代码逻辑和结构，例如： init: function() { // 获取配置信息 const config = getConfig(); // 获取用户信息 const userInfo = getUserInfo(); // 根据配置和用户信息，进行初始化 doInit(config, userInfo); // 如果存在自定义配置时的特殊逻辑 if (config.custom) { ... } } 特殊或不易理解写法的解释说明，例如： /** * parseInt was the reason my code was slow. * Bitshifting the String to coerce it to a * Number made it a lot faster. */ const val = inputValue &gt;&gt; 0; 特殊标记注释：如 TODO、FIXME 等有特殊含义的标记 文件注释：部分规约会约定在文件头部书写固定格式的注释，如注明作者、协议等信息 文档类注释：部分规约会约定 API、类、函数等使用文档类注释（如 jsdoc 风格） 遵循统一的风格规范，如一定的空格、空行，以保证注释自身的可读性 坏的注释包括： 注释对阅读代码无益：如本文第一个示例，本可以不用注释，用清晰的命名、逻辑进行代码自注释 未遵循统一的风格规范：如单行注释长度、空格、空行，例如： // bad 单行注释过长，不易阅读，应写成多行 // parseInt was the reason my code was slow.Bitshifting the String to coerce it to Number made it a lot faster. const val = inputValue &gt;&gt; 0; // good /** * parseInt was the reason my code was slow. * Bitshifting the String to coerce it to a * Number made it a lot faster. */ const val = inputValue &gt;&gt; 0; 情绪性注释：如抱怨、歧视、搞怪等（被发现你就跪了） 3、如何写好注释注释规约理解注释的目的和原则，制定并遵循一份注释规约，以保证注释的可读性和一致性 工具保障比如使用 ESLint 保证注释风格的一致，使用 Sonar 检查项目注释率 4、注释规约这里给出一份可供参考的注释规约（参考自airbnb规约）： ####4.1 【推荐】单行注释使用 // 注释应单独一行写在被注释对象的上方，不要追加在某条语句的后面： // bad const active = true; // is current tab // good // is current tab const active = true; 注释行的上方需要有一个空行（除非注释行上方是一个块的顶部），以增加可读性： // bad function getType() { console.log(&apos;fetching type...&apos;); // set the default type to &apos;no type&apos; const type = this.type || &apos;no type&apos;; return type; } // good function getType() { console.log(&apos;fetching type...&apos;); // set the default type to &apos;no type&apos; const type = this.type || &apos;no type&apos;; return type; } // good // 注释行上面是一个块的顶部时不需要空行 function getType() { // set the default type to &apos;no type&apos; const type = this.type || &apos;no type&apos;; return type; } 4.2 【推荐】多行注释使用 /* … /，而不是多行的 //// bad // make() returns a new element // based on the passed in tag name function make(tag) { // ... return element; } // good /** * make() returns a new element * based on the passed-in tag name */ function make(tag) { // ... return element; } 4.3 【强制】注释内容和注释符之间需要有一个空格，以增加可读性。eslint: spaced-comment// bad //is current tab const active = true; // good // is current tab const active = true; // bad /** *make() returns a new element *based on the passed-in tag name */ function make(tag) { // ... return element; } // good /** * make() returns a new element * based on the passed-in tag name */ function make(tag) { // ... return element; } 4.4 【推荐】使用特殊注释标记有时我们发现某个可能的 bug，但因为一些原因还没法修复；或者某个地方还有一些待完成的功能，这时我们需要使用相应的特殊标记注释来告知未来的自己或合作者。常用的特殊标记有两种： // FIXME: 说明问题是什么 // TODO: 说明还要做什么或者问题的解决方案 class Calculator extends Abacus { constructor() { super(); // FIXME: shouldn’t use a global here total = 0; // TODO: total should be configurable by an options param this.total = 0; } } 4.5 【推荐】文档类注释，如函数、类、文件、事件等，使用 jsdoc 规范例如： /** * Book类，代表一个书本. * @constructor * @param {string} title - 书本的标题. * @param {string} author - 书本的作者. */ function Book(title, author) { this.title=title; this.author=author; } Book.prototype={ /** * 获取书本的标题 * @returns {string|*} */ getTitle:function(){ return this.title; }, /** * 设置书本的页数 * @param pageNum {number} 页数 */ setPageNum:function(pageNum){ this.pageNum=pageNum; } }; 5、工具我们可以使用一些工具来保证注释质量，例如： Eslint：保证一致的注释风格 ESLint 是当下最流行的 JS 代码检查工具，ESLint 中有一些注释相关的规则，用户可选择开启： valid-jsdoc require-jsdoc no-warning-comments capitalized-comments line-comment-position lines-around-comment multiline-comment-style no-inline-comments spaced-comment Sonar：检查项目的注释率 Sonar 是一个代码持续集成平台，它可以对代码进行静态扫描，得到项目的注释率数据。 注释率反应了注释行占总代码行的比例，注释率太低不好，但也不能盲目追求高注释率。 另外，同 Eslint 类似，Sonar 也有一些针对注释风格规则可以配置。 6、后记理解注释的目的和原则，遵循一份注释规约并结合工具保证落地，可以使注释成为代码良好的辅助，增强可读性和可维护性，从而提高代码质量。]]></content>
      <categories>
        <category>注释</category>
      </categories>
      <tags>
        <tag>注释</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS选择器详解]]></title>
    <url>%2F2018%2F04%2F20%2FCSS%E9%80%89%E6%8B%A9%E5%99%A8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[选择器的种类有很多，可以到 w3cschool 去看看了解一下。也可以在 慕课网 中实践一下。 一、上下文选择器标签选择器&lt;style&gt; h1 {font-size: 16px;} p {color:red;} &lt;/style&gt; 代码中的h1和p就是选择器，他们是选择器里面最常用的一种，叫做标签选择器。我们可以直接通过标签元素来指定需要添加样式的位置。如果我们需要为多个标签添加同一种样式时，我们可以把它们组合在一起，每个标签选择器用“,”隔开，如下： &lt;style&gt; h1,h2,h3 { font-weight: bold; color: blue; } &lt;/style&gt; 这样的组合我们叫它分组选择器。 后代组合选择器当我们想为下面的article和aside的段落文本分别设置不同的字号时，我们就可以用到后代选择器了，它们是在祖先元素和后代元素之间加了一个空格，如代码所示： &lt;style&gt; article p { font-size: 12px; } aside p { font-size: 14px; } &lt;/style&gt; 后代选择器有一个问题就是，祖先元素选择的后代元素都会带有样式，但是我们有时候并不需要所有的标签都带有样式，这个时候我们就要用到其他的选择器了。 子选择器我们可以用DOM中的父子元素关系来选择，也就是子选择器，两个元素中间用“&gt;”来连接，如代码所示： &lt;style&gt; article&gt;p { font-size: 12px; } &lt;/style&gt; 同胞选择器我们也可以通过同胞关系来选择，叫做同胞选择器或者是兄弟选择器，这就意味着选择器的标签元素需要具有同一个父元素，它们之间用“+”来连接，例子： &lt;style&gt; h2+p { font-size: 12px; } &lt;/style&gt; 并且需要注意的是：p标签必须是紧跟在h2标签的后面。 一般同胞选择器一般同胞选择器中间用“~”连接。 &lt;style&gt; h2~p { font-size: 12px; } &lt;/style&gt; 一般同胞选择器和同胞选择器的区别就是，p标签不一定是紧跟在h2标签的后面。 通用选择器通用选择器是使用通配符“ * ”，它可以匹配任何元素。比如： *｛ color: green; ｝ 它会导致所有文本和边框都变成绿色。这里有个小知识： color属性设定的是前景色。前景色既影响文本也影响边框，但通常我们只用它设定文本颜色。 我们也可以这样使用通用选择器： p* { color: red; } 这样只会把p包含的所有元素的文本变成红色。通用选择器还有一个有意思的用法，就是可以用它构成一个非子选择器，比如： section*a { font-size: 1.3em; } 代码所表示的是，所有section的孙子元素，而非子元素的a标签都会被选中。这个从逻辑上来说也好理解，左边的section代表通配符的父元素，右边的a代表通配符的子元素，而*就是所有中间元素的集合。 以上就是通过DOM的层次结构的“上下文”关系来表示的选择器。 二、id和类选择器id和类选择器是我们在CSS中常用的选择器，它们可以更精确的定位到我们要添加样式的标签位置。只要在HTML标记中为元素添加id和class属性，就可以通过id和类选择器直接选择。 可以给id和class属性设定任何值，但不能以数字或特殊符号开头。 类选择器body标签包含的任何HTML元素都可以添加class属性，如： &lt;h1 class=&quot;specialtext&quot;&gt;这是一个H1标签&lt;/h1&gt; &lt;p&gt;这是一个段落。&lt;/p&gt; &lt;p class=&quot;specialtext featured&quot;&gt;这是另一个段落&lt;/p&gt; 1、类选择器然后我们就可以用类选择器添加样式了，类选择器前面要加一个“ . ” ，后面跟着类名，如下： &lt;style&gt; p { font-family: helvetica,sans-serif; } .specialtext { font-style: italic; } &lt;/style&gt; 2、标签带类选择器当然，需要更精确的也可以这样写： &lt;style&gt; p { font-family: helvetica,sans-serif; } .specialtext { font-style: italic; } p.specialtext { color: red; } p.specialtext span{ font-weight: bold; } &lt;/style&gt; 第三个样式只选择带.specialtext类的p，第四就更精确到p中的span元素了。 3、多类选择器同个标签可以存在多个类属性，每个类都用空格分隔，要选择两个类名可以这样写： &lt;style&gt; .specialtext.featured { font-size: 120%; } &lt;/style&gt; 注意：CSS类选择器的两个类名之间没有空格，如果加了空格就变成了“祖先/后代”关系的上下文选择器了。 ID选择器ID与类的写法相似，只不过id选择器前面用“ # ”后面跟着id名， &lt;style&gt; #specialtext { font-style: italic; } &lt;/style&gt; *** *** *** &lt;p id=&quot;specialtext&quot;&gt;这是一个特殊段落&lt;/p&gt; id还可以用于页内导航 &lt;a href=&quot;#bio&quot;&gt;Biography&lt;/a&gt; 这样的链接就可以直接在页面内跳转到具有id名为“bio”的标签的位置。如果没想好“href”中放什么链接，也可以用“#”来充当占位符。 什么时候用ID，什么时候用类1、什么时候用idid的用途是在页面中唯一地标识一个元素，强调的是唯一性。每个id名称必须是不相同的，而且每个id名称在页面中只能用一次。尤其是于JavaScript关联时，相同的id可能会导致JS行为异常。 2、什么时候用类类的目的是为了标识一组具有相同样式特征的元素，强调的是通用性。切不可乱用类，这样会增加需要编写和维护的CSS量。 总结（来自知乎：Milo） ID具有唯一性，Class具有普遍性。 ID是唯一的，所以尽量在结构外围使用，通常用于页面布局。 Class是可重复的，所以尽量在结构内部使用，通常用于样式定义。 ID的样式优先级高于Class。 三、属性选择器属性名选择器我们可能会遇到这样的HTML代码： &lt;img sec=&quot;images/yellow_flower.jpg&quot; title=&quot;yellow flower&quot; alt=&quot;yellow flower&quot; /&gt; 如果我们想要为带有title属性的图片添加样式，那么我们就可以用到属性名选择器了，如下： img[title] { border: 2px solid blue; } 这时，图片就会显示2像素宽的蓝色边框。一般来说title属性和alt属性都是设定相同的值，增加可阅读性。 属性值选择器属性值选择器就更精确地定位我们所需要添加样式的位置了。如下： img[title=&quot;red flower&quot;] { border: 4px solid green; } *** *** *** &lt;img src=&quot;images/red_flower.jpg&quot; title=&quot;red flower&quot; alt=&quot;red flower&quot; /&gt; 只有在title属性值为“red flower”时，才会为图片加上边框样式。 属性和值选择器-多个值[title~=&quot;hello&quot;]{ color: red; } 该例子为包含指定值的title属性的所有元素设置样式,适用于由空格分隔的属性值。 [lang|=en] { color: red; } 该例子为带有包含指定值的lang属性的所有元素设置样式。适用于由连字符分隔的属性值。 设置表单样式input[type=&quot;text&quot;]{ width: 50px; display: block; } input[type=&quot;button&quot;]{ width:12opx; margin-left:35px; } 选择器参考手册 [attribute] 用于选取带有指定属性的元素。 [attribute=value] 用于选取带有指定属性和值的元素。 [attribute~=value] 用于选取属性值中包含指定词汇的元素。 [attribute|=value] 用于选取带有以指定值开头的属性值的元素，该值必须是整个单词。 [attribute^=value] 匹配属性值以指定值开头的每个元素。 [attribute$=value] 匹配属性值以指定值结尾的每个元素。 [attribute*=value] 匹配属性值中包含指定值的每个元素。 四、伪类伪类与类相似，但它并没有附加到标记中的标签上，所以称之为伪类，伪类分两种： UI伪类，会在html元素处于特定状态时，为该元素应用CSS样式。 结构化伪类，会在标记中存在某种结构上的关系时，为相应的元素引用CSS样式。 UI伪类1、链接伪类针对连接的伪类一共有四个，也是我们常用伪类，它们的顺序也始终是这样的： a:Link {color: black;} /*链接等待被点击*/ a:visited {color: grey} /*用户此前点击过此链接*/ a:hover {text-decoration: none;} /*鼠标悬停在这个链接上*/ a:active {color:red;} /*链接正在被点击（鼠标按下还没有释放）*/ 一个冒号（:）表示伪类，两个冒号（::）表示CSS3新增的伪元素。很多时候不一定要将四个元素都写出来。而且这些伪类也可以用于任何元素，如下： p:hover {background-color: grey;} 这条代码就可以使鼠标悬停在p标签位置时，背景颜色变为灰色。 2、focus伪类任何元素都可以运用focus伪类，但一般用于表单： input：focus ｛background-color: yellow;｝ 表单中的文本框在用户单击它时会获取焦点，同时为该文本框添加一个黄色背景。 3、：target伪类如果用户点击一个指向页面中其他元素的链接，则那个元素就是目标（target），可以用:target选中它。 &lt;style&gt; #more_info:target {background:#eee;} &lt;/style&gt; &lt;a href=&quot;#more_info&quot;&gt;More Information&lt;/a&gt; &lt;h2 id=&quot;more_info&quot;&gt;This is the information you are looking for.&lt;/h2&gt; 用户单击链接跳转id为more_info的元素时，为该元素添加浅灰色背景。维基百科在其引证中就大量地使用了:target伪类。 结构化伪类1、:first-child和:last-child:first-child代表一组同胞元素中的第一个元素，而:last-child则代表最后一个。如下： &lt;style&gt; ol.results li:first-child { color: blue; } ol.results li:last-child { color: red; } &lt;/style&gt; &lt;ol class=&quot;results&quot;&gt; &lt;li&gt;MY FAST PONY&lt;/li&gt; &lt;li&gt;STEADY TROTTER&lt;/li&gt; &lt;li&gt;SLOW OL&apos;NAG&lt;/li&gt; &lt;/ol&gt; 2、nth-child(n)n可以是表示一个数值（也可以使用odd或者even表示奇数和偶数，也可用2n+1或者2n来表示），例如： li:nth-child(3) {color: grey;} :nth-child伪类最常用于提高表格的可读性，交替使用不同的颜色。 还有伪元素,内容有点多，就不一一介绍了。参考资料：《CSS设计指南》、w3cschool]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>选择器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js数组去重的几种方法]]></title>
    <url>%2F2018%2F01%2F27%2Fjs%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在工作中经常后台返回的数据，用户的输入==，都会有重复的数据的可能，所以，处理重复的数据是不可避免的，就总结一下数组的几种常见的去重方法 1.简单的去重方法最简单的数组去重法新建一新数组，遍历传入数组，值不在新数组就push进该数组中IE8以下不支持数组的indexOf方法 function uniq(array){ var temp = [];//一个新的临时数组 for(var i = 0; i &lt; array.length; i++){ if(temp.indexOf(array[i] == -1)){ temp.push(array[i]); } } return temp; } var aa = [1,2,2,3,4,3,4,5,6,7,8]; console.log(uniq(aa)); 2.对象键值法去重速度最快，占空间最多（空间换时间）该方法执行的速度比其他任何方法都快，就是占用的内存大一些。 思路：新建一js对象以及新数组，遍历传入数组时，判断值是否为js对象的键，不是的话给对象新增该键并放入数组。 注意点：判断是否为js对象键时，会自动对传入的键执行”toString()”, 不同的键可能会误认为一样，例如n[val] – n[1]、n[“1”]; 解决上述问题还是得调用”indexOf”。 function uniq(array){ var temp = {},r = [], len = array.length,val,type; for(var i = 0; i &lt; len; i++){ var array[i]; type = typeof val; if(!temp[val]){ temp[val] = [type]; r.push(val); }else if(temp[val].indexOf(type) &lt; 0){ temp[val].push(type); r.push(val); } } return r; } var aa = [1,2,3,&quot;3&quot;,4,9,&quot;a&quot;,3,5]; console.log(uniq(aa)); 3.排序后相邻去除法给传入数组排序，排序后相同值相邻， 然后遍历时，新数组只加入不与前一值重复的值。 会打乱原来数组的顺序 function uniq(array){ array.sort(); var temp = [array[0]]; for(var i = 0; i &lt; array.length; i++){ if(array[i] !== temp[temp.length-1]){ temp.push(array[i]); } } return temp; } var aa = [1,2,&quot;2&quot;,4,9,&quot;a&quot;,2,3,5,6]; console.log(uniq(aa)); 4.数组下标法还是得调用”indexOf”性能跟方法1差不多， 实现思路：如果当前数组的第i项在当前数组中第一次出现的位置不是i, 那么表示第i项是重复的，忽略掉。否则存入结果数组。 function uniq(array){ var temp = []; for(var i = 0;i &lt; array.length;i++){ //如果当前数组的第i项在当前数组中第一次出现的位置是i,才存入数组，否则代表是重复的 if(array.indexOf(array[i] == i)){ temp.push(array[i]); } } return temp; } var aa = [1,2,&quot;2&quot;,4,9,&quot;a&quot;,&quot;a&quot;,2,3,5,6,5]; console.log(uniq(aa)); 5.优化遍历数组法思路：获取没重复的最右一值放入新数组（检测到有重复值时终止当前循环同时进入顶层循环的下一轮判断） function uniq(array){ var temp = [],index = []; var l = array.length; for(var i = 0;i &lt; l;i++){ for(var j = i+1; j &lt; l;j++){ if(array[i] === array[j]){ i++; j = i; } } temp.push(array[i]); index.push(i); } console.log(index); return temp; } var aa = [1,2,2,3,5,3,6,5]; console.log(uniq(aa));]]></content>
      <categories>
        <category>JavaScript</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js数组的一些基本操作]]></title>
    <url>%2F2018%2F01%2F25%2Fjs%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[这几天因为工作上做的一些功能中需要大量的用到数组，对数组的各种操作，度娘了很多，基本上是需要用到什么就度娘什么，整理一下数组的知识，以后就不用总是去百度啦！ 创建数组的几种方式1、直接量创建var array = [];//创建一个空数组 var array = [1,2,3];//创建一个有三个元素的数组 2、构造函数创建var array = new Array();//创建空数组 var array = new Array(10);//创建一个长度为10的数组 var array = new Array(5,4,3,2,1)//创建数组并初始化 取值、赋值var item = array[index];//获取指定元素的值 array[index] = value; //为指定元素赋值 添加新元素array.push(item1,item2,...,itemN);//向数组的末尾添加一个或多个元素，并返回新数组的长度 array.unshift(item1,item2,...,itemN);//向数组的开头添加一个或多个元素，并返回新的长度 array.splice(index,howmany,item1,item2……itemN);//向/从数组中添加/添加项目，然后返回被删除的项目。 //注释:该方法会改变原始数组 index:必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置 howmany:必需。要删除的项目数组。如果设置为0，则不会删除项目。 item1,item2……itemN 可选。向数组添加的新项目 删除元素array.pop();//删除最后一个元素，并返回该元素 array.shift();//删除第一个元素，数组元素位置自动迁移，返回被删除的元素 array.splice(start,delCount);//从start的位置开始向后删除delCount个元素 根据指定下标删除数组元素列了这么都就是没有发现删除数组元素的方法！于是查了一些资料找到了解决方法。删除数组元素需要扩展Array原型prototype将一下代码放在全局js文件中 Array.prototype.remove=function(obj){ for(var i = 0;i &lt; this.length;i++){ var temp = this[i]; if(!isNaN(obj)){ temp=i; } if(temp == obj){ for(var j = i;j &lt;this.length;j++){ this[j]=this[j+1]; } this.length = this.length-1; } } } 使用方法 var arr =new Array(); arr[0]=&quot;dddddd&quot;; arr[1]=&quot;dxxxxxxx&quot;; arr[2]=&quot;vvvvvvv&quot;; arr[3]=&quot;dbbbbb&quot;; var str =&quot;vvvvvvv&quot;; arr.remove(3);//删除下标为3的对象 arr.remove(str);//删除对象值为“vvvvvvv” 数组的合并、截取array.slice(start,end)//从已有的数组中返回选定的元素所组成的一个新数组，包含startdao end(不包括该元素) start:必需。规定从start开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。-1指最后一个元素，以此类推。 end:可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。 如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。 array.concat(array1,array2);//用于连接两个或多个数组 该方法不会改变现有的数组，返回一个新的数组。 数组的排序array.reverse();//数组反转 array.sort();//数组排序，返回数组地址 数组转字符串方法1var a,,c; a = new Array(a,b,c,d,e); b = a.join(&apos;-&apos;);//a-b-c-d-e 使用-拼接数组元素 c = a.join(&apos;&apos;);//abcde 方法2var arr = new Array(3) arr[0] = &quot;George&quot; arr[1] = &quot;John&quot; arr[2] = &quot;Thomas&quot; document.write(arr.toString()) 输出： George,John,Thomas 字符串转数组使用split()方法用于把一个字符串分割成字符串数组 语法：stringObject.split(separator,howmany) separator：必需。字符串或正则表达式，从该参数指定的地方分割 stringObject。 howmany：可选。该参数可指定返回的数组的最大长度。 如果设置了该参数，返回的子串不会多于这个参数指定的数组。 如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。 例子1： var str=&quot;How are you doing today?&quot; document.write(str.split(&quot; &quot;) + &quot;&lt;br /&gt;&quot;) document.write(str.split(&quot;&quot;) + &quot;&lt;br /&gt;&quot;) document.write(str.split(&quot; &quot;,3)) 输出： How,are,you,doing,today? H,o,w, ,a,r,e, ,y,o,u, ,d,o,i,n,g, ,t,o,d,a,y,? How,are,you 也可以使用正则表达式作为 separator var words = sentence.split(/\s+/) 清空数组的三种方法方法1：splice方法splice()方法用于插入、删除或替换数组的元素。 var arr = [1, 2, 3, 4]; arr.splice(2,1,&quot;Lemon&quot;,&quot;Kiwi&quot;); //第一个参数为删除和添加数组的起始位置， //第二个参数为删除多少个元素， //第三个参数为添加新的元素 console.log(arr) //输出1,2,Lemon,Kiwi,4 所以清空数组相当于删除数组中的所有元素 var arr = [1, 2, 3, 4]; arr.splice(0, arr.length); console.log(arr); //输出[]，空数组 方法2：赋值length为0javascript中数组的length和其他的语言的数组中length不同，js中数组length可以自己设置大小，意思是可读可写的，但其他语言如java,c++中都是不能进行修改，只读形式存在。如java中对数组length赋值将报错 但在js中则可以修改，这样就达到了清空数组的目的 var arr = [1, 2, 3, 4]; arr.length = 0; console.log(arr); //输出[]，空数组 方法三：数组赋值[]var arr = [1, 2, 3, 4]; arr = []; 这里其实并不能说是严格意义的清空数组，只是将arr重新赋值为空数组 之前的数组如果没有引用在指向它将等待垃圾回收。]]></content>
      <categories>
        <category>JavaScript</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[站在2018]]></title>
    <url>%2F2018%2F01%2F22%2F%E7%AB%99%E5%9C%A82018%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[css五种方式实现页脚置底]]></title>
    <url>%2F2017%2F05%2F12%2Fcss%E4%BA%94%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E9%A1%B5%E8%84%9A%E7%BD%AE%E5%BA%95%2F</url>
    <content type="text"><![CDATA[*页脚置底（Stick footer）就是让网页的footer部分始终在浏览器窗口的底部。当网页内容足够长以至超出浏览器可视高度时，页脚会随着内容被推到网页底部；但如果网页不够长，置底的页脚就会保持在浏览器窗口底部。 方法一：将内容部分的margin-bottom设为负数&lt;div class=&quot;wrapper&quot;&gt; &lt;!--content--&gt; &lt;div class=&quot;push&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt;footer&lt;/div&gt; css: html,body{ margin: 0; padding: 0; height: 100%; } .wrapper { min-height: 100%; margin-bottom: -50px;/*等于footer的高度*/ } .footer,.push { height: 50px; } 1.这个方法需要容器里有额外的站位元素（div.push）。2.div.wrapper的margin-bottom需要和div.footer的-height值一样，注意是负height。 方法二：将页脚的margin-top设为负数给内容外增加父元素，并让内容部分的padding-bottom与页脚的height相等。 &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;content-inside&quot;&gt; &lt;!-- content --&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt;footer&lt;/div&gt; css: html,body { margin: 0; padding: 0; height: 100%; } .content{ min-height: 100%; } .content-inside { padding: 20px; padding-bottom: 50px; } .footer { height: 50px; margin-top: -50px; } 方法三：使用calc()设置内容高度&lt;div class=&quot;content&quot;&gt; &lt;!-- content --&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt;footer&lt;/div&gt; css: .content { min-height: calc(100vh - 70px); } .footer { height: 50px; } 这里假设div.content和div.footer之间有20px的间距，所以70px=50px+20px 方法四：使用flexbox弹性盒布局以上三种方法的footer高度都是固定的，如果footer的内容太多则可能会破坏布局。 &lt;div class=&quot;content&quot;&gt; &lt;!-- content --&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt;footer&lt;/div&gt; css: html { height: 100%; } body { min-height: 100%; display: flex; flex-direction: column; } .content { flex: 1; } 方法五：使用Grid网格布局&lt;div class=&quot;content&quot;&gt; &lt;!-- content --&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt;footer&lt;/div&gt; css: html { height: 100%; } body { min-height: 100%; } .footer { grid-row-start: 2; grid-row-end: 3; }]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[吕蒙正-《破窑赋》]]></title>
    <url>%2F2017%2F04%2F20%2F%E5%90%95%E8%92%99%E6%AD%A3-%E3%80%8A%E7%A0%B4%E7%AA%91%E8%B5%8B%E3%80%8B%2F</url>
    <content type="text"><![CDATA[今天看到一篇很好的文章，网上称之为千古奇文。 对古文知之甚少，初读，只觉得确实好，是不是千古奇文，大家自有评断。好文章，那必须记录一下，待以后再细细品读。 《破窑赋》，别名《寒窑赋》，是北宋大臣吕蒙正的作品，相传此赋是作者为了劝诫太子而创作的。作者以自己从贫苦到富贵的经历，并列举了历史上诸多名人的起伏命运，来说明一种自然循环的人生思想。 如今读来，朗朗上口，其状物之精、明理之深，堪称一代奇文。 将社会的各种人情冷暖、现实无奈，写得那么真实且入心。 全文如下： 天有不测风云，人有旦夕祸福。蜈蚣百足，行不及蛇;雄鸡两翼，飞不过鸦。马有千里之程，无骑不能自往;人有冲天之志，非运不能自通。 盖闻人生在世，富贵不能淫，贫贱不能移。文章盖世，孔子厄于陈邦;武略超群，太公钓于渭水。颜渊命短，殊非凶恶之徒;盗跖年长，岂是善良之辈。尧帝明圣，却生不肖之儿;瞽叟愚顽，反生大孝之子。 张良原是布衣，萧何称谓县吏。晏子身无五尺，封作齐国宰相;孔明卧居草庐，能作蜀汉军师。楚霸虽雄，败于乌江自刎;汉王虽弱，竟有万里江山。 李广有射虎之威，到老无封;冯唐有乘龙之才，一生不遇。韩信未遇之时，无一日三餐，及至遇行，腰悬三尺玉印，一旦时衰，死于阴人之手。 有先贫而后富，有老壮而少衰。满腹文章，白发竟然不中;才疏学浅，少年及第登科。深院宫娥，运退反为妓妾;风流妓女，时来配作夫人。 青春美女，却招愚蠢之夫;俊秀郎君，反配粗丑之妇。蛟龙未遇，潜水于鱼鳖之间;君子失时，拱手于小人之下。 衣服虽破，常存仪礼之容;面带忧愁，每抱怀安之量。时遭不遇，只宜安贫守份;心若不欺，必然扬眉吐气。初贫君子，天然骨骼生成;乍富小人，不脱贫寒肌体。 天不得时，日月无光;地不得时，草木不生;水不得时，风浪不平;人不得时，利运不通。注福注禄，命里已安排定，富贵谁不欲?人若不依根基八字，岂能为卿为相? 吾昔寓居洛阳，朝求僧餐，暮宿破窖，思衣不可遮其体，思食不可济其饥，上人憎，下人厌，人道我贱，非我不弃也。 今居朝堂，官至极品，位置三公，身虽鞠躬于一人之下，而列职于千万人之上，有挞百僚之杖，有斩鄙吝之剑，思衣而有罗锦千箱，思食而有珍馐百味，出则壮士执鞭，入则佳人捧觞，上人宠，下人拥。人道我贵，非我之能也，此乃时也、运也、命也。 嗟呼!人生在世，富贵不可尽用，贫贱不可自欺，听由天地循环，周而复始焉。 【译文】 天气的变化是很难预测的，人早晚的命运是很难说的。蜈蚣虽然有百十条腿，但爬行却不如蛇(快)。 家鸡的羽翅很大，但却不能像鸟儿一样飞翔。好马可以驰骋千里，但是没有人驾驭是不能来回的。每个人都有远大的志向，但是要有机会才可以飞黄腾达。 就算是文章再好，孔子尚且被困于陈蔡。打仗的方法再多，姜太公也是先在渭水河畔钓鱼。 偷盗的人活长了，不是善良的人。颜回的命短，却不是凶恶之徒。尧舜虽然是至圣的明君，却生下了不肖的儿子。瞽叟虽然顽皮呆板，但却生下世称大圣的儿子。 张良原本是老百姓，萧何称他是治县的能手。晏子身高不足五尺，却被封为齐国丞相。 孔明居住在草庐中，却能做西蜀的军师。韩信双手没有捉鸡的力气，却被封为汉朝的大将。 冯唐虽然有治国安邦的志向，到死也没有个一官半职。李广虽然有箭射猛虎的威名，却一直没有封侯。楚王项羽虽然兵强，难免吴江自刎。汉王刘邦虽兵弱，却有江山万里。 满腹的学问，一生没有中榜。只有一点的知识，在少年却已经当官。有的人是先富而后贫，有的人是有先贫而后富。 蛟龙没有被发现的时候，和鱼虾在一起。君子失宠时，委曲于小人的手下。天气不好的时候，太阳，月亮都没有光辉。大地不的时宜的时候，寸草不长。 补充： 河水不流畅时，水浪滔滔。人不的时宜时，即不能发财也不能做官。过去的时候，我在洛阳，白天在寺庙里读书，夜晚在破窑里住宿。 身上穿的破布衣服尚且不能掩盖我的全身，淡如水的米粥不能摊薄我的肚子。逼我好的人憎恨我，比我低的人讨厌我，都说我是贫贱的人! 我说：不是我贫贱，是时运和命运啊!等到我中了状元，官位到了最高，位列三公(三公，国代最高的官员)有鞭打百官的禅杖，有斩杀吝啬之徒的宝剑，出去的时候有士兵为我拿着鞭子，进家的时候有人为我提着衣服，想穿衣服有的是绫罗绸缎，先吃东西的时候有的是山珍海味。 上面的人宠信我，下面的人奉承我，人人都仰慕我，都说我是贵人! “孔子尚困于陈邦”，春秋时期，孔子周游列国，被困于陈国的蔡地。 “太公垂钓于渭水”,姜尚为得到周文王的注意，在为谁钓鱼。 “盗跖年长，不是善良之辈”，盗跖，古代的一个盗匪。他活的名比较长，相传活了70岁。 “颜回命短”，颜回，孔子的弟子，从才华出众，可惜命短。 “尧舜至圣，却生不肖之子，”尧舜都是上古的明君，相传舜的儿子大禹是暴君。 作者简介 吕蒙正（944或946—1011），北宋大臣。字圣功，洛阳（今属河南省）人。公元977年（宋太宗太平兴国二年）丁丑科状元。授将作监丞，通判升州。再著作郎，入值史馆。公元980年（太平兴国五年），拜左补阙，知制诰。后任参知政事。公元988年（端拱元年），拜为宰相。为人质厚宽简，素有重望，以正道自持，遇事敢言。每论时政，有不允者，必不强力推行。与开国元老赵普同在相位，关系极为融洽。公元991年（淳化二年），贬为吏部尚书。两年后复以本官入相。公元995年（至道元年），再度罢相。真宗即位，任命吕蒙正为左仆射。公元1001年（咸平四年），第三次登上相位。后封莱国公，授太子太师。不久，因病辞官，回归故里。卒谥文穆，赠中书令。]]></content>
      <categories>
        <category>古诗词</category>
      </categories>
      <tags>
        <tag>古诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli+webpack项目环境搭建(一)]]></title>
    <url>%2F2017%2F04%2F15%2Fvue-cli-webpack%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[安装环境1.node.js安装node.js官网下载 最新的node.js都有自带npm（包管理工具） 安装完成后，可以在命令行中输入node -v He npm -v,如果能显示出版本号，就说明安装成功了。 毕竟npm的服务器在国外，有时候安装依赖的时候可能会很慢很慢，这个时候可以选择安装淘宝镜像来安装我们的依赖，安装命令如下： npm install -g cnpm --registry= https://registry.npm.taobao.org 现在就可以使用cnpm来安装我们所需的各种依赖了。 2.安装vue-cli安装好node，我们可以直接全局安装vue-cli： npm install -g vue-cli 或者 cnpm install -g vue-cli 最新的vue项目模板中，都带有webpack插件，所以这里可以不安装webpack，安装完成后，可以使用vue -V(注意V大写)查看是否安装成功。如果提示“无法识别‘vue’”,有可能是npm版本过低，可以使用 npm install -g npm 更新版本 3.创建项目搭建方式 # 使用vue-cli初始化项目 vue init webpack my-project # 进入到目录 cd my-project # 安装依赖 npm install # 开始运行 npm run dev 上面的这些命令会从 vuejs-templates 拉取模板并安装，然后用NPM安装依赖，最后你只需要用个NPM脚本启动就能开始开发了 官方模板所有的官方模板都可以在 vuejs-templates organization找到。如果有一个新的模板放在了这里，你可以直接就用 vue init 使用。你也可以运行 vue list 命令来看看现在有哪些官方模板是现在可用的。 目前可供选择的模板： browserify - 拥有高级功能的 Browserify + vueify 用于正式开发。 browserify-simple - 拥有基础功能的 Browserify + vueify 用于快速原型开发。 webpack - 拥有高级功能的 Webpack + vue-loader 用于正式开发。 webpack-simple - 拥有基础功能的 Webpack + vue-loader 用于快速原型开发。 4.生成项目命令vue init webpack my-project执行之后，会在当前目录生成以该名称命名的项目文件夹 配置完成后，可以看到目录下多出了一个项目文件夹，里面就是 vue-cli 创建的一个基于 webpack 的 vue.js 项目然后进入项目目录（cd my-project），使用 npm 安装依赖 npm install 然后启动项目 npm run dev 如果浏览器打开之后，没有加载出页面，有可能是本地的 8080 端口被占用，需要修改一下配置文件 config&gt;index.js 建议将端口号改为不常用的端口。另外我还将 build 的路径前缀修改为 ‘ ./ ‘（原本为 ‘ / ‘），是因为打包之后，外部引入 js 和 css 文件时，如果路径以 ‘ / ‘ 开头，在本地是无法找到对应文件的（服务器上没问题）。所以如果需要在本地打开打包后的文件，就得修改文件路径。 5.打包上线自己的项目文件都需要放到 src 文件夹下项目开发完成之后，可以输入 npm run build 来进行打包工作 npm run build 打包完成后，会生成 dist 文件夹，如果已经修改了文件路径，可以直接打开本地文件查看项目上线时，只需要将 dist 文件夹放到服务器就行了]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue基础</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F04%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2017%2F04%2F05%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[前两天看了网站上别人的个人博客，哎呀我的妈，是真好看啊。于是按照网上的资料也自己弄了一个，毕竟我也是有买了域名的人呀，不能让域名白买了，其实不买域名其实也是可以的，既然有一个域名那就用上吧，显得逼格高 自己刚开始弄的时候觉得这个挺有逼格的，总的来说就是用了hexo+github来创建的，最基本就是这样了（所以其实并没有很高逼格的感觉）。 记录一下在创建这个个人博客时对我帮助比较大的几篇文章 首先要用hexo肯定官网是最好最权威的：Hexo 官网然后就是部署到github上去了：Hexo+Github,搭建属于自己的博客（这篇文章不是一般的“啰嗦”，作者写得好详细）一个博客必须有个好看的主题：GithubPages+Hexo博客主题YiliaYilia主题作者的博客：Litten的博客（也是用的他的主题，拿人手短呀） 最后一个就是学习markdown的语法了，自己现在才勤快一点去接触这些东西，（真的太懒惰了，要挨三十大板），以后这个博客就是我的个人小天地了]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
